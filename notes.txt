typescript special types

typescript has special types that may not refer to any special type of data,

a> :any
~any is a type that disables type checking and effectively allows all types to be used.

b> :unknown
~is a similar, but safer alternative to any, TS will prevent unknown types from being used, it used when you don't know the type of data being typed, to add a type later we can cast using "as"keyword.

c>: never
~ it effectively throws an error whenever it is defined, it's rarely used, especially by itself its primary use is in advanced generics.

d>: undefined & null
~ they are types that refer to the javascript primitives undefined and null respectively.


TYPESCRIPT ARRAYS
a>: Readonly
~ it prevents arrays from being changed

b>: Type Inference
~ TS can infer the type of an array if it has values.

TYPESCRIPT TUPLES
a>: Typed arrays
~ a tuple is a typed array with a pre-defined length and types for each index, tuples are great because they allow each element in the array to be a know type of value, to define a tuple specify the type of each element in the array.

b>: Readonly tuple
~  a good practice is to make your tuple Readonly, tuples only have strongly defined types for the initial values.

c>: Named tuples
~ allows us to provide context for our values at each index e.g (```const graph: [x:number, y: number]= [55.2, 41.3]```),  they provide more context for what our index values represent.

d>: Destructuring tuples
~ since tuples are arrays we can destructure them e.g(```const graph: [number,number]=[55.1,41.5]; const [x,y]= graph```),

TYPESCRIPT OBJECT TYPES
a>: Type Inference
~ if you have a number you can't assign a string to it i will result to an error. TS can infer the types of properties based on their values.

b>: Optional properties
~ they are properties that don't have to be defined in the object definition.

c>: index signatures
~ they can be used for object without a defined list of properties.


TYPESCRIPT ENUMS
~ enums is a special class that represents a group of constants(unchangeable variables). they come in two flavors string and numeric.

a>: Numeric Enums - Default
~ by default enums will initialize the first value to 0 and add 1 to each additional value.

b>: Numeric Enums - Initialized
~  you can set the value of the first numeric enum and have it auto increment from that.

c>: Numeric Enums - Fully Initialized
~ you can assign unique number values for each enum value then the value will not increment automatically

d>: string Enums
~ they are more common since they can be read and intent

TYPESCRIPT TYPE ALIASES AND INTERFACES
~ TS allows types to be defined separately from the variables then use them. aliases and interfaces allows types to be easily shared between different variables/objects.

a>: Type aliases
~ it allows defining types with a custom name(an Alias)
~ they can be primitives like strings or complex types such as objects and arrays. 

b>: interfaces
~ interfaces are similar to type aliases, expect they only apply to object types.

c>:extending interfaces
~ it means you are creating a new interface with the same properties as the original, plus something new


TYPESCRIPT UNION TYPES
~ union types are used when a value can be more than a single type,such as when a property would be string or number.

a>: union|(OR)
~ using the | we are saying our parameter is a string or number

b>: union type error
~ you need to know what type is when union types are being used to avoid errors


TYPESCRIPT FUNCTIONS
~ TS has specific syntax for typing function parameters and return values

a>: Return Type
~ the type of the value returned by the function can be explicitly defined. note: if no return type is defined, TS  will attempt to infer it through the type of the variables or expression returned.

b>: void return type
~ the type of void can be used to indicate a function doesn't return any value.

c>: parameters
~ functions parameters are typed with a similar syntax as variables declarations, if no parameter type is defined TS will default to using any, unless additional type information is available.

d>: optional parameter
~ by default TS will assume all parameters are required but they can be explicitly marked as optional


f>: default parameters
~ for params with default values, the default value goes after the type annotation